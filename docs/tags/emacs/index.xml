<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>emacs on patrolli</title>
    <link>https://patrolli.github.io/xssq/tags/emacs/</link>
    <description>Recent content in emacs on patrolli</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 10 Apr 2021 00:37:09 +0800</lastBuildDate><atom:link href="https://patrolli.github.io/xssq/tags/emacs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>目录下 org 文件自动导出成 hugo md 文件</title>
      <link>https://patrolli.github.io/xssq/post/%E7%9B%AE%E5%BD%95%E4%B8%8B_org_%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%87%BA%E6%88%90_hugo_md_%E6%96%87%E4%BB%B6/</link>
      <pubDate>Sat, 10 Apr 2021 00:37:09 +0800</pubDate>
      
      <guid>https://patrolli.github.io/xssq/post/%E7%9B%AE%E5%BD%95%E4%B8%8B_org_%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%87%BA%E6%88%90_hugo_md_%E6%96%87%E4%BB%B6/</guid>
      <description>Intro 目前在从 org 使用 ox-hugo 导出成 hugo 的 blog 时，只能手动的执行 C-c C-e, 然后选择导出成 Hugo 形式的 markdown. 如果原始的 org 文件进行了修改，就需要每次自己手动去进行导出，有一些不方便，所以我想写一个函数，来直接将指定目录下，所有已经导出过 hugo blog 的 org 文件，全部重新导出，这样只要定期执行这个命令，就可以保证文件在修改后能够被更新地导出到 hugo blogs.</description>
    </item>
    
    <item>
      <title>hugo 博客搭建</title>
      <link>https://patrolli.github.io/xssq/post/hugo_%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Fri, 09 Apr 2021 19:46:58 +0800</pubDate>
      
      <guid>https://patrolli.github.io/xssq/post/hugo_%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</guid>
      <description>基本安装与使用 Hugo 安装 直接在官网下载 Hugo 的安装包
本地创建 根据官网的 quick start, 创建一个 site 只需如下几个命令
hugo server 部署到 github pages github pages 有两种形式，一种是针对用户的 pages: .</description>
    </item>
    
    <item>
      <title>配置 emacs-rime</title>
      <link>https://patrolli.github.io/xssq/post/2021-02-17-18-48/</link>
      <pubDate>Wed, 17 Feb 2021 00:00:00 +0800</pubDate>
      
      <guid>https://patrolli.github.io/xssq/post/2021-02-17-18-48/</guid>
      <description>配置 emacs rime 安装   安装 librime, 其他系统参考：emacs-rime/INSTALLATION.org at master · DogLooksGood/emacs-rime
sudo apt install librime-dev
  安装 emacs rime rime 在 melpa 源中已经发布，故可以直接安装</description>
    </item>
    
    <item>
      <title>hugo&amp;org-mode&amp;ox-hugo 的博客工作流</title>
      <link>https://patrolli.github.io/xssq/post/hugo-workflow/</link>
      <pubDate>Thu, 11 Feb 2021 17:51:00 +0800</pubDate>
      
      <guid>https://patrolli.github.io/xssq/post/hugo-workflow/</guid>
      <description>两种工作流 ox-hugo 有两种 work-flow: 一种是 one-post-per-subtree, 另一种是 one-post-per-file. ox-hugo 起到的作用实际是将我们写的 org 文件导出成 md, 并且生成 hugo 需要的 md 头文件信息，例如：
+++ title = &amp;#34;hugo&amp;amp;org-mode&amp;amp;ox-hugo 的博客工作流&amp;#34; author = [&amp;#34;LAPTOP-4COO4EVU&amp;#34;] categories = [&amp;#34;computer&amp;#34;] draft = false +++ 这两种 workflow 的主要区别在于，如果是使用 headline, 我们不需要重复地设置 org 文件的 hearder 部分，并且可以利用 headline 的 todo state, tags, property 来设置导出的 markdown 元信息。</description>
    </item>
    
    <item>
      <title>org 整理 paper_index</title>
      <link>https://patrolli.github.io/xssq/post/org_%E6%95%B4%E7%90%86_paper_index/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://patrolli.github.io/xssq/post/org_%E6%95%B4%E7%90%86_paper_index/</guid>
      <description>#+date 2021-4-19
Intro 花了一些时间用 elisp 写了一个函数，将 paper-index 中维护的论文索引按照他们的 tag 来进行分组。之前我是对每篇论文用一个一级 headline 进行维护，然后插入对应的 tag, 但这样做有一些弊端，首先是一篇论文可能会有多个 tag, 一一加上后整行就会显得很长，窗口小了的话就会折行，看着就不舒服了；二是不方便检索，如果知道论文题目，可以直接搜索，但有时候会忘记论文的题目，需要浏览来查找，虽然可以通过 tag 来过滤 (org-tags-views), 但每次都需要输入命令，而且会将 filter 的结果放在一个新的 buffer 中，也不太方便。所以我想对此进行一些改进，目标是能够将每个论文的 headline （或者在这里说索引）按照其 tag 复制到对应的以 tag 命名的一级标题下（论文的索引就变成二级标题）。在一开始添加论文的时候，可以先放在一个 Un-archieve 的标题下，然后执行命令去根据它的 tag 来移动到对应的分组下，同时删去他在 Un-archieve 的索引。另外，之后也昆虫为某个论文索引再添加 tag, 然后再次执行命令，又可以将这个索引复制到对应的 tag headline 下。如果在 Un-archieve 中的论文索引的 tag 已经被复制到 tag 的 headline 下，那么这个 tag 就被移除，如果 Un-archieve 中的论文索引没有 tag, 那么执行命令就会删除掉这个索引（只在 Un-archieve 下面有效）。代码如下：</description>
    </item>
    
  </channel>
</rss>
